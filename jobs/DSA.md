# Data structures and algorithms
thinking out loud and creating a dialog with the interviewer is key

- use certain data structures to solve problems
- compare various approaches and explain why the one you selected was the right one

## what is being assessed:
- most efficient run-time solutions
- some DS are better for reading data, some for writting
- algorithms should be as fast as possible and solve the problems at hand
- care for edge cases

## what to prepare:
- consider runtimes and memory usage for common operations
- understand DS in core libraries
    - tree, hashmaps, lists, arrays, queues, etc)
- understand common algorithms:
    - traversals, divide and conquer, bfs, dfs
- discuss runtimes, theoretical limititations, implementations strategies
- suggested:
    - binary search tree data
    - scalability methods to customize and improve the design of a system:
        - redundancy
        - partitioning
        - caching
        - indexing
        - load balancing
        - queue

# how to showcase DSA
what do strong DSA skills look like and how to demonstrate them

## optimization
use optimal DSA to solve the problem
- get toolbox of useful DSA in common scenarios
    - efficient access by key/object/position
    - maintaining sort order
    - searching
    - finding min/max
- thing edge cases(hash collision, degenerate binary tree)
- features and DSA in language of choice
- dive deep to see more of them
- if picking between two DSA, explain why
- think of benefit, operations and complexity

## identify shortcomings
identify shortcomings and discuss tradeoffs with DSA
- if you know a DSA that is better but are not confident, say it
- identify the pattern but don't overcomplicate it

## justification
justify the use of DSA
- multiple ways to solve it
- show understanding of the DSA

## runtime and space tradeoffs
- demonstrate Big O understanding
- first think of DSA, think big O and then address and try to solve